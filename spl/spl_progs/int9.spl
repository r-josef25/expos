[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 9;
alias userSP R0;
userSP = SP;
[PROCESS_TABLE +([SYSTEM_STATUS_TABLE + 1]*16) +13] = SP;
SP = [PROCESS_TABLE +([SYSTEM_STATUS_TABLE + 1]*16) +11]*512 - 1; 
alias physicalPageNum R1;
alias offset R2;
alias filenamePhysicalAddr R3;
physicalPageNum = [PTBR + 2 * ((userSP - 4)/ 512)];
offset = (userSP - 4) % 512;
filenamePhysicalAddr = (physicalPageNum * 512) + offset;
alias filename R4;
filename=[filenamePhysicalAddr];
alias i_e R5;
i_e = 0;
alias blk R6;
blk = -1;
while(i_e < MAX_FILE_NUM)do
	if([INODE_TABLE + (i_e*16) + 1] == filename)then
		blk = INODE_TABLE + (i_e*16) + 8;
		break;
	endif;
	i_e = i_e + 1;
endwhile;
if(i_e == MAX_FILE_NUM || [INODE_TABLE + i_e*16] != EXEC)then
	alias physicalAddrRetVal R5;
	physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512);
	[physicalAddrRetVal] = -1;
else
	multipush(R0, R1, R2, R3, R4, R5, R6);
	R1 = 3;
	R2 = [SYSTEM_STATUS_TABLE + 1];
	call MOD_1;
	multipop(R0, R1, R2, R3, R4, R5, R6);
	alias uap R7;
	uap = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16 + 11];
	[MEMORY_FREE_LIST + uap] = [MEMORY_FREE_LIST + uap] + 1;
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
	SP = uap*512 - 1;
	alias ri R2;
	ri = 0;
	while(ri < 16)do
		[(uap + 1)*512 - 16 + ri] = -1;
		ri = ri + 2;
	endwhile;
	alias pid R8;
	alias proc R9;
	pid = [SYSTEM_STATUS_TABLE + 1];
	proc = pid*16 + PROCESS_TABLE;
	[proc + 4] = RUNNING;
	[proc + 7] = i_e;
	[PTBR] = 63;
	[PTBR + 1] = "0100";
	[PTBR + 2] = 64;
	[PTBR + 3] = "0100";
	multipush(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9);
	[PTBR + 4] = -1;
	[PTBR + 5] = "0000";
	[PTBR + 6] = -1;
	[PTBR + 7] = "0000";
	R1 = 1;
	call MOD_2;
	[PTBR + 16] = R0;
	[PTBR + 17] = "0110";
	R1 = 1;
	call MOD_2;
	[PTBR + 18] = R0;
	[PTBR + 19] = "0110";
	multipop(R0, R1, R2, R3, R4, R5, R6, R7, R8, R9);
	multipush(R0,R1,R2,R3,R4,R5, R6, R7, R8, R9, R10);
	R1 = 5;
	R2 = [blk];
	multipush(R6);
	call MOD_2;
	multipop(R6);
//	multipush(R0);
//	R1 = 2;
//	R2 = [SYSTEM_STATUS_TABLE + 1];
//	R3 = R0;
//	R4 = [blk];
//	call MOD_4;
//	multipop(R0);
	[PTBR + 8] = R0;
	[PTBR + 9] = "0100";
//	alias blkno R10;
//	blkno = 0;
//	while( [blk] != -1 && blkno < 4 )do
//		multipush(R5, R6, R7, R8, R9, R10);
//		R1 = 1;
//		call MOD_2;
//		multipop(R5, R6, R7, R8, R9, R10);
//		multipush(R0, R5, R6, R7, R8, R9, R10);
//		R1 = 2;
//		R2 = [SYSTEM_STATUS_TABLE + 1];
//		R3 = R0;
//		R4 = [blk];
//		call MOD_4;
//		multipop(R0, R5, R6, R7, R8, R9, R10);
//		[PTBR + 8 + blkno*2] = R0;
//		[PTBR + 8 + blkno*2 + 1] = "0100";
//		blkno = blkno + 1;
//		blk = blk + 1;
//	endwhile;

	multipop(R0,R1,R2,R3,R4,R5, R6, R7, R8, R9, R10);
	alias disk R10;
	disk = DISK_MAP_TABLE + 2 + [SYSTEM_STATUS_TABLE + 1]*10;
	[disk] = -1;
	[disk+1]= -1;
	[disk+2]= [blk];
	[disk+3]= [blk + 1];
	[disk+4]= [blk + 2];
	[disk+5]= [blk + 3];
	[disk+6]= -1;
	[disk+7]= -1;
	[[PTBR + 16]*512] = [[PTBR + 8]*512 + 1];
	SP = 8*512;
	[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
	ireturn;
endif;
SP = [PROCESS_TABLE +([SYSTEM_STATUS_TABLE + 1]*16) +13];
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
ireturn;
